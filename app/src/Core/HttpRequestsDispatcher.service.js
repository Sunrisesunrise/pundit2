angular.module('Pundit2.Core')

// Service used to dispatch/handle (from both the embedded and chrome-extension versions)
// http requests to the annotation server
// Note: Some http calls in the application are simply sent using the $http module
// the HttpRequestsDispatcher is used only when necessary to avoid CORS errors (chrome-extension)
.service('HttpRequestsDispatcher', function(BaseComponent, $q, $http) {
    var disp = new BaseComponent('HttpRequestsDispatcher');

    
    // variable indicating if the application is in the embedded or chrome-extension version
    var isEmbedded = true;

    if (window.chrome && chrome.runtime && chrome.runtime.id) {
       isEmbedded = false;
    }

    // sends an http request to the annotation server changing the actual send procedure
    // based on whether the application is in the embedded or the chrome-extension version
    disp.sendHttpRequest = function(httpRequestObject){
        if(isEmbedded) return sendHttpRequest_embedVersion(httpRequestObject);
        else return sendHttpRequest_chromeExtensionVersion(convertHttpRequestForFetch(httpRequestObject));
    }


    // converts an http request object (created to be used with the $http module)
    // in a tuple of three values: url for the sending of the request in embedded mode,
    // urlSuffix for the sending of the request in chome-extension mode and an http request
    // object reaqdy to be sent using the standard fetch method
    // Note: for a POST's payload, $http uses "data" whilst fetch uses "body",
    // this function therefore renames the "data" property into "body"
    function convertHttpRequestForFetch(httpRequestObject){
        var newHttpRequestObject = {};
        var url = httpRequestObject.url;

        var paramsAngularJson = false;
        if( httpRequestObject.paramsAngularJson )
            paramsAngularJson = true;

        if( httpRequestObject.params!=null ){
            url += '?';
            Object.keys(httpRequestObject.params)
            .forEach(function(key){
                var paramKeyValue = httpRequestObject.params[key];
                if(!paramsAngularJson) paramKeyValue = JSON.stringify(paramKeyValue);
                url += key + '=' + encodeURI(paramKeyValue) + '&';
            });
            url = url.substring(0,url.length-1);
        }

        var urlSuffix = httpRequestObject.urlSuffix;
        urlSuffix = url.substring(url.indexOf(urlSuffix));

        var relevantFields = ['method', 'headers', 'data', 'withCredentials', 'cache'];
        relevantFields.forEach(function(fieldName){
          if(httpRequestObject.hasOwnProperty(fieldName)){
            if(fieldName=='cache'){
                if(httpRequestObject[fieldName]==false)
                    httpRequestObject[fieldName] = 'no-cache';
                else if(httpRequestObject[fieldName]==true)
                    httpRequestObject[fieldName] = 'default';
            }

            if(fieldName=='data'){
                var bodyValue = httpRequestObject[fieldName];
                if( typeof(bodyValue)!=='string' ) bodyValue = JSON.stringify(bodyValue);
                newHttpRequestObject.body = bodyValue;
            } else
                newHttpRequestObject[fieldName] = httpRequestObject[fieldName];
          }
        });

        return {
            'url':url,
            'urlSuffix':urlSuffix,
            'httpRequestObject':newHttpRequestObject
        };
    }


    // sends the http request in the embedded version of the application
    // and returns a promise
    function sendHttpRequest_embedVersion(httpRequestObject){
        var promise = $q.defer();

        delete httpRequestObject.urlSuffix;
        $http(httpRequestObject).success(function (data) {
            promise.resolve(data);
        }).error(function() {
            promise.reject({'error':true,'status':error.status});
        });

      return promise.promise;
    }


    // sends an http request tuple (generated by the convertHttpRequestForFetch function)
    // to the backgorundHttpRequestsHandler so it can send the request in the chrome-extension
    // version without getting a CORS error
    function sendHttpRequest_chromeExtensionVersion(httpRequestObjectTuple){
        var promise = $q.defer();
        chrome.runtime.sendMessage({isHttpRequest: true, httpRequestObjectTuple: httpRequestObjectTuple}, function(response){
                if(response.error==true){
                    promise.reject({'error':true,'status':response.status});
                }else{
                    var data = response;
                    promise.resolve(data);
                }
        });
        return promise.promise;
    }


    return disp;
});